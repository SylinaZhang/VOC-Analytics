AWSTemplateFormatVersion: '2010-09-09'
Description: 'Voc demo stack'

Parameters:
  BucketPrefix:
    Type: String
    Default: 'voc-workshop'
    Description: 'Prefix for the S3 bucket name'

Resources:
  # init S3 bucket
  S3Bucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub 
        - "${BucketPrefix}-${StackIdSuffix}"
        - StackIdSuffix: !Select 
            - 2
            - !Split 
              - "/"
              - !Ref AWS::StackId
  # init DynamoDB tables for tag management 
  DynamoDBTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: voc_tags
      AttributeDefinitions:
        - AttributeName: category_id
          AttributeType: N
      KeySchema:
        - AttributeName: category_id
          KeyType: HASH
      ProvisionedThroughput:
        ReadCapacityUnits: 5
        WriteCapacityUnits: 5
  # init lambda
  LambdaFunctionDataPreview:
    Type: AWS::Lambda::Function
    Properties:
      Handler: index.lambda_handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Runtime: python3.10
      Timeout: 10
      Code:
        ZipFile: |
          import json
          import boto3
          import logging
          import os
          from decimal import Decimal

          # 初始化日志
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)
            
          # 获取region环境变量
          region = os.environ.get('AWS_REGION')

          # 初始化客户端
          dynamodb_client = boto3.resource('dynamodb', region_name=region)


          # 文件类型与source data的映射         
          FILE_MAPPING = {
                  1001: {'category': 'clothes', 'table_name': 'voc_data_clothes_1001'},
                  2001: {'category': '3c', 'table_name': 'voc_data_3c_2001'},
                  3001: {'category': 'pets', 'table_name': 'voc_data_pets_3001'}
              }
          def lambda_handler(event, context):

              # 从event中获取category_id类型
              category_id = int(event.get('category_id'))
              
              if not category_id:
                  return {
                      'statusCode': 400,
                      'body': json.dumps('Missing category_id in the request')
                  }
                  
              # 检查文件类型是否有效
              if category_id not in FILE_MAPPING:
                  return {
                      'statusCode': 400,
                      'body': json.dumps(f'Invalid category_id: {category_id}')
                  }
              

              # 构建完整的S3文件路径
              table_name = f"{FILE_MAPPING[category_id]['table_name']}"

              preview_result = {}

              try:
                  # 读取DynamoDb数据源， 10条数据
                  table = dynamodb_client.Table(table_name)
                  response = table.scan(Limit=10)
                  data_preview_result = response['Items']
                  
                  # 将Decimal类型转换为float，确保可以JSON序列化
                  def decimal_default(obj):
                      if isinstance(obj, Decimal):
                          return float(obj)
                      raise TypeError
                  
                  # 读取prompt
                  system_prompt = "You are an experienced e-commerce reviews ananlyor.Your task is to perform aspect-based sentiment analysis (ABSA) on customer reviews."
                  user_prompt = '''Your job is to summarize terms in reviews from the following aspects in <aspects> tags.
                      - The each term you summarized must be simplified less than 5 words with its corresponding sentiment "positive" or "negative".
                      - Please answer in only English lowercase letters in JSON format like {{aspect:[{{\"term\": tag, \"sentiment\": sentiment}},], }}.
                      - Please conduct a product review analysis from the aspects metioned below based on the following reviews: {review}
                      <aspects>
                      <aspect>advantages</caspect>
                      <aspect>disadvantages</caspect>
                      <aspect>motivations</caspect>
                      <aspect>expectations</caspect>
                      </aspects>
                  '''
                  
                  prompt_preview_result = {
                      'system_prompt': system_prompt,
                      'user_prompt': user_prompt
                  }
                  
                  preview_result = {
                      'prompt': prompt_preview_result,
                      'data': json.loads(json.dumps(data_preview_result, default=decimal_default))
                  }

                  return {
                      'statusCode': 200,
                      'body': preview_result
                  }
              except Exception as e:
                  return {
                      'statusCode': 500,
                      'body': str(e)
                  }

  LambdaFunctionGenerateTags:
    Type: AWS::Lambda::Function
    Properties:
      Handler: index.lambda_handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Runtime: python3.10
      Timeout: 120
      MemorySize: 1024
      EphemeralStorage:
       Size: 512
      ReservedConcurrentExecutions: 100
      Code:
        ZipFile: |
          import boto3
          import json
          import random
          from botocore.exceptions import ClientError
          import logging
          import os
          import threading
          from botocore.config import Config
          from collections import defaultdict
          from operator import itemgetter

          # 配置连接池大小
          my_config = Config(
              max_pool_connections=100  # 根据需要调整这个值
          )

          # 初始化日志
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          # 获取region环境变量
          region = os.environ.get('AWS_REGION')


          # 初始化客户端
          dynamodb_client = boto3.resource('dynamodb', region_name=region, config=my_config)
          bedrock_client = boto3.client(service_name='bedrock-runtime', region_name=region, config=my_config)

          # # 从环境变量获取配置

          # 文件类型与data文件+prompt文件路径的映射
          FILE_MAPPING = {
                1001: {'category': 'clothes', 'table_name': 'voc_data_clothes_1001'},
                2001: {'category': '3c', 'table_name': 'voc_data_3c_2001'},
                3001: {'category': 'pets', 'table_name': 'voc_data_pets_3001'}
            }

          # 获取 voc_tags 表
          tags_table = dynamodb_client.Table('voc_tags')
              
          def lambda_handler(event, context):
              logger.info("Starting VOC  Tag Generate!!!")
              # 从event中获取category_id类型, 检查合理性
              try: 
                  category_id = int(event.get('category_id'))
                  system_prompt = str(event.get('system_prompt'))
              except (TypeError, ValueError):
                  logger.error("Invalid or missing category_id in the request")
                  return {'statusCode': 400, 'body': json.dumps('Invalid or missing category_id')}
              if category_id not in FILE_MAPPING:
                  logger.error(f"Invalid category_id: {category_id}")
                  return {'statusCode': 400, 'body': json.dumps(f'Invalid category_id: {category_id}')}
              source_table_name = f"{FILE_MAPPING[category_id]['table_name']}"
              destination_table_name = f"sample_review_{category_id}"
              create_table_if_not_exists(destination_table_name)
              
              # 读取源表数据
              sample_ratio = 0.2
              items = read_samples_from_dynamodb(source_table_name, sample_ratio)
              execute_num = 100
              
              multiThread(items, system_prompt, destination_table_name, execute_num)
              tags_items = read_dynamodb_table(destination_table_name)
              top_n = 20
              top_n_items = get_top_n_terms(top_n, tags_items)
              print("top_n_items is" + str(top_n_items))
              
              aspect_tags = {}
              # 为每个aspect创建单独的terms列表
              aspect_terms = {}
              for aspect, terms_dict in top_n_items.items():
                  aspect_terms[aspect] = list(terms_dict.keys())
                  # aspect_tags_str = '[' + tag_aggregation(aspect, aspect_terms[aspect]) + ']'
                  # aspect_tags[aspect] =  json.loads(aspect_tags_str)
                  aspect_tags_json = json.loads(tag_aggregation(aspect, aspect_terms[aspect]))
                  print("aspect_tags_json type for "+ str(aspect) + " is: " + str(type(aspect_tags_json)))  
                  print("aspect_tags_json  for "+ str(aspect) + " is: " + str(aspect_tags_json))  
                  aspect_tags.update(aspect_tags_json)
                  
              #print("aspect_tags for "+ str(aspect) + " is: " + str(aspect_tags))    
              # 将字典转换为JSON字符串
              tags_json = json.dumps(aspect_tags)
              
              # 将数据插入到DynamoDB表中
              try:
                  tags_item = {
                          'category_id': category_id,
                          'tags': tags_json
                      }
                  response = tags_table.put_item(
                      Item=tags_item
                  )
                  print("Tags 数据成功插入到DynamoDB")
                  return {
                      'statusCode': 200, 
                      'body': json.dumps(tags_item)
                      }
              except Exception as e:
                  print(f"插入数据时发生错误: {str(e)}")
              
          def generate_labels(review, system_prompt):
              user_prompt = f'''Your job is to summarize terms in reviews from the following aspects in <aspects> tags.
                          - The each term you summarized must be simplified less than 5 words with its corresponding sentiment "positive" or "negative".
                          - Please answer in only English lowercase letters in JSON format like {{aspect:[{{\"term\": tag, \"sentiment\": sentiment}},], }}.
                          - Please conduct a product review analysis from the aspects metioned below based on the following reviews: {review}
                          <aspects>
                          <aspect>advantages</caspect>
                          <aspect>disadvantages</caspect>
                          <aspect>motivations</caspect>
                          <aspect>expectations</caspect>
                          </aspects>
                          '''
              body = json.dumps({
                  "anthropic_version": "bedrock-2023-05-31",
                  "max_tokens": 512,
                  "temperature": 0.5,
                  "system": system_prompt,
                  "messages": [
                      {
                          "role": "user",
                          "content": [{"type": "text", "text": user_prompt}],
                  }
              ],
              })
              
              model_id = 'anthropic.claude-3-sonnet-20240229-v1:0'
              accept = 'application/json'
              content_type = 'application/json'
              
              response = bedrock_client.invoke_model(body=body, modelId=model_id, accept=accept, contentType=content_type)
              
              response_body = json.loads(response["body"].read())
              
              # text
              completion = response_body["content"][0]["text"]
            
              try: 
                  completion = completion.replace("json", "")
                  completion = completion.replace('```', '')
                  completion = completion[completion.find('{'):]
                  labels = json.loads(completion)
                  return labels
              except json.JSONDecodeError:
                  print(f"Error parsing LLM response for review: {review}")
                  return None
                  
                  
          def read_samples_from_dynamodb(table_name, sample_ratio=0.1):
              table = dynamodb_client.Table(table_name)
              # 获取表的总项目数
              # 如果表很大,需要处理分页
              total_items= total_items_from_DynamoDB(table)
              # 计算需要采样的数量
              sample_size = int(total_items * sample_ratio)
              print("total_items is:" + str(total_items))
              # 初始化结果列表和已处理的项目数
              sampled_items = []
              processed_items = 0
              
              # 使用 ExclusiveStartKey 进行分页扫描
              scan_kwargs = {}
              while processed_items < total_items:
                  response = table.scan(**scan_kwargs)
                  items = response.get('Items', [])

                  for item in items:
                      processed_items += 1
                      
                      # 使用概率采样来决定是否包含此项
                      if random.random() < (sample_size - len(sampled_items)) / (total_items - processed_items + 1):
                          sampled_items.append(item)

                      # 如果已经采样足够的数量，就停止
                      if len(sampled_items) >= sample_size:
                          return sampled_items

                  # 更新 ExclusiveStartKey 以继续扫描
                  scan_kwargs['ExclusiveStartKey'] = response.get('LastEvaluatedKey')
                  
                  # 如果没有更多的项目，就退出循环
                  if not scan_kwargs.get('ExclusiveStartKey'):
                      break
              return sampled_items
              
          def write_to_dynamodb(table_name, item):
              table = dynamodb_client.Table(table_name)
              try:
                  table.put_item(Item=item)
              except ClientError as e:
                  print(f"Error writing to DynamoDB: {e.response['Error']['Message']}")

          def create_table_if_not_exists(table_name):
              
              try:
                  # 尝试获取表信息,如果表存在则不会抛出异常
                  table = dynamodb_client.Table(table_name)
                  table.load()
                  print(f"Table {table_name} already exists")
                  # 扫描表中所有项目
                  scan = table.scan()
                  
                  with table.batch_writer() as batch:
                      for item in scan['Items']:
                          # 获取主键
                          key = {
                              'partition_key': item['review_id']
                          }
                          # 删除项目
                          batch.delete_item(Key=key)
                  
                  # 处理分页结果
                  while 'LastEvaluatedKey' in scan:
                      scan = table.scan(ExclusiveStartKey=scan['LastEvaluatedKey'])
                      with table.batch_writer() as batch:
                          for item in scan['Items']:
                              key = {
                                  'partition_key': item['review_id']
                              }
                              batch.delete_item(Key=key)
              except ClientError as e:
                  if e.response['Error']['Code'] == 'ResourceNotFoundException':
                      # 表不存在,创建新表
                      print(f"Table {table_name} does not exist. Creating...")
                      table = dynamodb_client.create_table(
                          TableName=table_name,
                          KeySchema=[
                              {
                                  'AttributeName': 'review_id',
                                  'KeyType': 'HASH'  # 主键
                              }
                          ],
                          AttributeDefinitions=[
                              {
                                  'AttributeName': 'review_id',
                                  'AttributeType': 'S'  # 字符串类型
                              }
                          ],
                          ProvisionedThroughput={
                              'ReadCapacityUnits': 5,
                              'WriteCapacityUnits': 5
                          }
                      )
                      
                      # 等待表创建完成
                      table.meta.client.get_waiter('table_exists').wait(TableName=table_name)
                      print(f"Table {table_name} created successfully")
                  else:
                      print(f"Error checking/creating table: {e}")

          def total_items_from_DynamoDB(table):
              total_items=0
              response = table.scan(
                  Select='COUNT'
              )
              total_items = response['Count']
              while 'LastEvaluatedKey' in response:
                  response = table.scan(
                      Select='COUNT',
                      ExclusiveStartKey=response['LastEvaluatedKey']
                  )
                  total_items += response['Count']
              return total_items

          def task(item, system_prompt, destination_table_name):
              #print(f"Thread {i} started")
              review = item.get('review', '')
              if review == 'nan':
                  return
              review_id = item.get('review_id', '')
              labels = generate_labels(review, system_prompt)
              if labels:
                  # 准备新的item
                  new_item = {
                      'review_id': review_id,
                      'expectations': labels.get('expectations', []),
                      'advantages': labels.get('advantages', []),
                      'disadvantages': labels.get('disadvantages', []),
                      'motivations': labels.get('motivations', [])
                  }
                  # 写入新表
                  write_to_dynamodb(destination_table_name, new_item)
                  print(f"Processed and wrote review_id: {review_id}")
              #print(f"Thread {i} finished")
              

              
          def multiThread(items, system_prompt, destination_table_name, execute_num):
              items_len = len(items)
              threads = []
              execute_times = items_len // execute_num
              last_remains = items_len % execute_num
              if last_remains > 0:
                  execute_times = execute_times + 1;
              for j in range(execute_times):
                  if j < execute_times - 1:
                      for i in range(execute_num * j,execute_num * (j + 1)):
                          t = threading.Thread(target=task, args=(items[i], system_prompt, destination_table_name))
                          threads.append(t)
                          t.start()
                  else:
                      for i in range(execute_num * j,execute_num * j + last_remains):
                          t = threading.Thread(target=task, args=(items[i], system_prompt, destination_table_name))
                          threads.append(t)
                          t.start()
                          

                  for t in threads:
                      t.join()
                      
                      
          def read_dynamodb_table(table_name):
              table = dynamodb_client.Table(table_name)
              
              items = []
              scan_kwargs = {}
              done = False
              
              while not done:
                  response = table.scan(**scan_kwargs)
                  items.extend(response.get('Items', []))
                  scan_kwargs['ExclusiveStartKey'] = response.get('LastEvaluatedKey', None)
                  done = scan_kwargs['ExclusiveStartKey'] is None
              
              return items
              
          def get_top_n_terms(top_n, items):
              top_aspects = {}
              aspect_counts = defaultdict(lambda: defaultdict(int))
              
              for item in items:
                  for aspect in ['expectations', 'advantages', 'disadvantages', 'motivations']:
                      for term_info in item.get(aspect, []):
                          term = term_info.get('term', '')
                          if term:
                              aspect_counts[aspect][term] += 1
              for aspect, terms in aspect_counts.items():
                  sorted_terms = sorted(terms.items(), key=itemgetter(1), reverse=True)[:top_n]
                  top_aspects[aspect] = dict(sorted_terms)
              
              return top_aspects
              
          def tag_aggregation(aspect, terms):

              # Define the model ID for Claude 3.5 Sonnet
              model_id = 'anthropic.claude-3-sonnet-20240229-v1:0'
              system_prompt = """You are an experienced e-commerce reviews ananlyor.Your task is to perform aspect-based sentiment analysis (ABSA) on customer reviews"""

              prompt = f"""Given the following list of terms in <term>  for in {aspect}. Please cluster these terms into 10 representative terms. 
              - Terms with similar or the same meaning should be merged into one term, while preserving the original intent.
              - The each term in English lowercase letters you summarized must be simplified between 2 and 3 words with its corresponding one-sentence detailed description.
              - you only can output English lowercase letters for terms.
              <term>{terms}</term>
              - If insufficient terms(less than 10 terms) in {terms}, allow to cluster these terms into less than 10 representative terms.
              With out any Explanation and without any Format tag.Return the term names immediately in JSON format:
              - Output result in JSON format like {{{aspect}:[{{\"term\": tag, \"description\": description}},], }}.
              """
              messages = [{"role": "user", "content": [{"type": "text", "text": prompt}]}, {"role": "assistant", "content": [
                  {"type": "text",
                  "text": 'Here is reslut in the requested JSON format:```json'}]}]

              request_body = json.dumps({
                  "anthropic_version": "bedrock-2023-05-31",
                  "max_tokens": 1000,
                  "system": system_prompt,
                  "messages": messages,
                  "stop_sequences": ["```"]
              }
              )

              response = bedrock_client.invoke_model(body=request_body, modelId=model_id)
              response_body = json.loads(response.get('body').read())
              response_text = response_body['content'][0]['text']

              return response_text
              
  LambdaFunctionReviewAnalysis:
    Type: AWS::Lambda::Function
    Properties:
      Handler: index.lambda_handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Runtime: python3.10
      Timeout: 120
      MemorySize: 1028
      EphemeralStorage:
       Size: 1024
      ReservedConcurrentExecutions: 200
      Code:
        ZipFile: |
          import json
          import boto3
          import uuid
          import threading
          import logging
          from botocore.config import Config
          from boto3.dynamodb.conditions import Key
          from botocore.exceptions import ClientError
          import os

          # 配置连接池大小
          my_config = Config(
            max_pool_connections=200  # 根据需要调整这个值
          )

          # 初始化日志
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          # 获取region环境变量
          region = os.environ.get('AWS_REGION')

          # 初始化客户端
          dynamodb_client = boto3.resource('dynamodb', region_name=region, config=my_config)
          bedrock_client = boto3.client(service_name='bedrock-runtime', region_name=region, config=my_config)


          # 文件类型与data文件+prompt文件路径的映射
          FILE_MAPPING = {
              1001: {'category': 'clothes', 'table_name': 'voc_data_clothes_1001'},
              2001: {'category': '3c', 'table_name': 'voc_data_3c_2001'},
              3001: {'category': 'pets', 'table_name': 'voc_data_pets_3001'}
          }
          # 获取 voc_tags 表
          tags_table = dynamodb_client.Table('voc_tags')

          #model ID
          model_sonnet = 'anthropic.claude-3-sonnet-20240229-v1:0'
          model_haiku = 'anthropic.claude-3-haiku-20240307-v1:0'
          model_opus = 'anthropic.claude-3-opus-20240229-v1:0'


          def lambda_handler(event, context):
              logger.info("Starting VOC analysis")
              # 从event中获取category_id类型, 检查合理性
              try: 
                  category_id = int(event.get('category_id'))
                  system_prompt = str(event.get('system_prompt'))
              except (TypeError, ValueError):
                  logger.error("Invalid or missing category_id in the request")
                  return {'statusCode': 400, 'body': json.dumps('Invalid or missing category_id')}
              if category_id not in FILE_MAPPING:
                  logger.error(f"Invalid category_id: {category_id}")
                  return {'statusCode': 400, 'body': json.dumps(f'Invalid category_id: {category_id}')}
              
              #source table in DDB
              source_table_name = f"{FILE_MAPPING[category_id]['table_name']}"
              
              # 准备review分析结果的DynamaoDB表格
              table_name = f'tagged_reviews_{category_id}'
              create_table_if_not_exists(table_name)
              # table = dynamodb_client.Table(table_name)

              tags_data = get_tags_data(category_id)
              if not tags_data:
                  return {'statusCode': 404, 'body': json.dumps('Tags data not found')}
              

                  
              #获得source table in DDB
              source_table_name = f"{FILE_MAPPING[category_id]['table_name']}"
              
              all_items = read_all_items_from_dynamodb(source_table_name)
              execute_num = 200
              
              multiThread(all_items, system_prompt, table_name, execute_num, tags_data)
              
              logger.info("VOC Analysis completed successfully")
              return {'statusCode': 200, 'body': json.dumps('VOC Analysis Success!')}
              
              
          def claude_complete_classifier(prompt, system_prompt):
              body = json.dumps({
                  "anthropic_version": "bedrock-2023-05-31",
                  "max_tokens": 2048,
                  "temperature": 0.01,
                  "system": system_prompt,
                  "messages": [
                      {
                          "role": "user",
                          "content": [{"type": "text", "text": prompt}],
                  }
              ],
              })
              
              model_id = model_sonnet
              accept = 'application/json'
              content_type = 'application/json'
              
              response = bedrock_client.invoke_model(body=body, modelId=model_id, accept=accept, contentType=content_type)
              
              response_body = json.loads(response["body"].read())
              
              # text
              completion = response_body["content"][0]["text"]
              return completion

          def get_analysis_tags_result(review,tags_data):
              result = {}
              # 提取 aspects tags
              advantage_tags = tags_data.get('advantages', [])
              disadvantage_tags = tags_data.get('disadvantages', [])
              motivations_tags = tags_data.get('motivations', [])
              expectations_tags = tags_data.get('expectations', []) 
              try: 
                  system_prompt = """You are an experienced e-commerce reviews ananlyor.Your task is to perform aspect-based sentiment analysis (ABSA) on historical customer reviews"""
                  llm_prompt = f'''You are an AI assistant trained to categorize user feedback for different aspects in <aspect> tag into the corresponding aspect's predefined tags in <tag> tags based on descriptions of tags, along with sentiment analysis for each tag. Your goal is to analyze each piece of review, assign the most relevant tags, and determine the sentiment (positive, negative) associated with each tag based on the review content. When analyzing a certain aspect, you can only classify it into the given tags within the aspect. For example, you only can categorize reviews into tags below the sentense "The <aspect>advantages</caspect> corresponding tags: "  . You only need to perform classification, and do not need to generate any other content.
                          - Output result in JSON format like {{aspect:[{{\"term\": tag, \"sentiment\": sentiment}},], }}.
                          - Please conduct a product review analysis from the aspect categories metioned below based on the following reviews in <review>
                  
                          <aspects>
                          <aspect>advantages</caspect>
                          <aspect>disadvantages</caspect>
                          <aspect>motivations</caspect>
                          <aspect>expectations</caspect>
                          </aspects>
                          
                          aspect of advantages: {advantage_tags}
                          
                          aspect of disadvantages：{disadvantage_tags}
                          
                          aspect of motivations：{motivations_tags}
                  
                          aspect of expectations: {expectations_tags}
                          
                          <review>{review}</review>
                      
                          ''' 
                  llm_result = claude_complete_classifier(llm_prompt, system_prompt)
                  llm_result = llm_result.replace("json", "")
                  llm_result = llm_result.replace('```', '')
                  llm_result = llm_result[llm_result.find('{'):]
                  result = json.loads(llm_result)  
              except:
                  # 处理其他类型异常的代码
                  print(llm_result)
              
              return result    
              
          def task(item, system_prompt, destination_table_name, tags_data):
              table = dynamodb_client.Table(destination_table_name)
              #print(f"Thread {i} started")
              review = item.get('review', '')
              if review == 'nan':
                  return
              review_id = item.get('review_id', '')
              result = get_analysis_tags_result(review, tags_data)
              if result:
                  # 准备新的item
                  new_item = {
                      'review_id': review_id,
                      'review': review
                  }
                  item.update(result)
                  # 写入新表
                  try:
                      table.put_item(Item=item)
                      print(f"Processed and wrote review_id: {review_id}")
                  except ClientError as e:
                      print(f"Error writing to DynamoDB: {e.response['Error']['Message']}")
              #print(f"Thread {i} finished")
              

          def create_table_if_not_exists(table_name):
              
              try:
                  # 尝试获取表信息,如果表存在则不会抛出异常
                  table = dynamodb_client.Table(table_name)
                  table.load()
                  print(f"Table {table_name} already exists")
              except ClientError as e:
                  if e.response['Error']['Code'] == 'ResourceNotFoundException':
                      # 表不存在,创建新表
                      print(f"Table {table_name} does not exist. Creating...")
                      table = dynamodb_client.create_table(
                          TableName=table_name,
                          KeySchema=[
                              {
                                  'AttributeName': 'review_id',
                                  'KeyType': 'HASH'  # 主键
                              }
                          ],
                          AttributeDefinitions=[
                              {
                                  'AttributeName': 'review_id',
                                  'AttributeType': 'S'  # 字符串类型
                              }
                          ],
                          ProvisionedThroughput={
                              'ReadCapacityUnits': 5,
                              'WriteCapacityUnits': 5
                          }
                      )
                      
                      # 等待表创建完成
                      table.meta.client.get_waiter('table_exists').wait(TableName=table_name)
                      print(f"Table {table_name} created successfully")
                  else:
                      print(f"Error checking/creating table: {e}")
                      
                      
          def get_tags_data(category_id):
              try:
                  response = tags_table.get_item(Key={'category_id': category_id})
                  print(response)
                  if 'Item' in response:
                      return json.loads(response['Item']['tags'])
                  else:
                      logger.warning(f"No item found with category_id: {category_id}")
                      return None
              except ClientError as e:
                  logger.error(f"Error getting tags data: {e}")
                  raise
              
              
          def read_all_items_from_dynamodb(table_name):
              table = dynamodb_client.Table(table_name)
              
              all_items = []
              scan_kwargs = {}
              
              try:
                  while True:
                      response = table.scan(**scan_kwargs)
                      all_items.extend(response.get('Items', []))
                      
                      # 更新 ExclusiveStartKey 以继续扫描
                      scan_kwargs['ExclusiveStartKey'] = response.get('LastEvaluatedKey')
                      
                      # 如果没有更多的项目，就退出循环
                      if not scan_kwargs.get('ExclusiveStartKey'):
                          break
                  
                  print(f"Successfully read {len(all_items)} items from table {table_name}")
                  return all_items
              
              except ClientError as e:
                  print(f"Error reading items from DynamoDB: {e.response['Error']['Message']}")
                  return []

          def multiThread(items, system_prompt, destination_table_name, execute_num, tags_data):
              items_len = len(items)
              threads = []
              execute_times = items_len // execute_num
              last_remains = items_len % execute_num
              if last_remains > 0:
                  execute_times = execute_times + 1;
              for j in range(execute_times):
                  if j < execute_times - 1:
                      for i in range(execute_num * j,execute_num * (j + 1)):
                          t = threading.Thread(target=task, args=(items[i], system_prompt, destination_table_name, tags_data))
                          threads.append(t)
                          t.start()
                  else:
                      for i in range(execute_num * j,execute_num * j + last_remains):
                          t = threading.Thread(target=task, args=(items[i], system_prompt, destination_table_name, tags_data))
                          threads.append(t)
                          t.start()
                          

                  for t in threads:
                      t.join()


  LambdaFunctionAnalysisMetrics:
    Type: AWS::Lambda::Function
    Properties:
      Handler: index.lambda_handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Runtime: python3.10
      Timeout: 30
      MemorySize: 512
      EphemeralStorage:
       Size: 512
      Code:
        ZipFile: |
          import boto3
          import json
          from collections import Counter
          import logging
          from botocore.exceptions import ClientError

          # 初始化日志
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          # 创建 DynamoDB 客户端
          dynamodb = boto3.resource('dynamodb')

          def lambda_handler(event, context):
              # 从event中获取category_id类型, 检查合理性
              try: 
                  category_id = int(event.get('category_id'))
              except (TypeError, ValueError):
                  logger.error("Invalid or missing category_id in the request")
                  return {'statusCode': 400, 'body': json.dumps('Invalid or missing category_id')}
                  
              try: 
                  # 连接到指定的表
                  table_name = f'tagged_reviews_{category_id}'
                  table = dynamodb.Table(table_name)
                  # 扫描表以获取所有数据
                  data = scan_table_completely(table)
                  total_items = len(data)  # 计算data中item的总数
              except Exception as e:
                  logger.error(f"Unexpected error: {str(e)}")
                  return {'statusCode': 500, 'body': json.dumps('An unexpected error occurred')}
                  
              
              aspects = ["advantages", "disadvantages", "motivations", "expectations"]

              terms_percentage_collections = {}
              tag_total_count = {}
              sentiment_percentages = {}
              aspect_item_counts = {aspect: 0 for aspect in aspects}
              positive_percentage, negative_percentage = calculate_sentiment_percentages(data, aspects)
              sentiment_percentages = {
                      "positive_percentage": f"{positive_percentage:.2f}%",
                      "negative_percentage": f"{negative_percentage:.2f}%"
                  }
              for aspect in aspects:
                  terms_percentage, total_count = get_terms_percentage(data, aspect)
                  terms_percentage_collections[aspect]=terms_percentage
                  tag_total_count[aspect] = total_count
                  aspect_item_counts[aspect] = count_items_with_aspect(data, aspect)
              return {
                  'statusCode': 200,
                  'body': json.dumps({
                      "term_percentage": terms_percentage_collections,
                      "tag_total_count": tag_total_count,
                      "review_total_count": total_items,
                      "sentiment_percentages": sentiment_percentages,
                      "aspect_item_counts": aspect_item_counts
                  })
              }
              
          def scan_table_completely(table):
              """
              完整扫描DynamoDB表，处理分页
              
              Args:
              table (boto3.resource('dynamodb').Table): DynamoDB表对象
              
              Returns:
              list: 表中所有项目的列表
              """
              data = []
              scan_kwargs = {}
              done = False
              start_key = None
              while not done:
                  if start_key:
                      scan_kwargs['ExclusiveStartKey'] = start_key
                  response = table.scan(**scan_kwargs)
                  data.extend(response.get('Items', []))
                  start_key = response.get('LastEvaluatedKey', None)
                  done = start_key is None
              return data


          def get_terms_percentage(data, aspect_name):
              # 解析特性属性值，将 sentiment 和 term 存储到合适的数据结构中
              terms = []

              for item in data:
                  aspects = item.get(aspect_name, [])
                  for aspect in aspects:
                      term = aspect.get('term')
                      # term = aspect.get('M', {}).get('term', {}).get('S', '')
                      if term:
                          terms.append(term)

              # 统计 term 的出现次数
              term_count = Counter(terms)
              # 计算总数以便计算占比
              total_count = sum(term_count.values())
              
              # 返回空列表和0，避免零除错误
              if total_count == 0:
                  return [], 0  
              
              # 计算每个 term 的占比
              term_percentage = {term: f"{(count / total_count) * 100:.2f}%" for term, count in term_count.items()}
              # 按占比百分比倒序对结果进行排序
              sorted_terms_percentage = sorted(term_percentage.items(), key=lambda x: x[1], reverse=True)
              
              return sorted_terms_percentage, total_count
              
          def calculate_sentiment_percentages(data, aspects):
              """
              Calculate the percentage of positive and negative terms for a given aspect
              
              Args:
              data (list): The list of tagged reviews
              aspect_name (str): The name of the aspect to analyze
              
              Returns:
              tuple: Positive and negative term percentages
              """
              positive_terms = []
              negative_terms = []
              
              for item in data:
                  for aspect_name in aspects:
                      aspects_list = item.get(aspect_name, [])
                      for aspect in aspects_list:
                          sentiment = aspect.get('sentiment')
                          term = aspect.get('term')
                          if sentiment == 'positive':
                              positive_terms.append(term)
                          elif sentiment == 'negative':
                              negative_terms.append(term)
              
              total_positive = len(positive_terms)
              total_negative = len(negative_terms)
              total_terms = total_positive + total_negative
              
              if total_terms == 0:
                  return 0, 0  # 防止除以零
              
              positive_percentage = (total_positive / total_terms) * 100
              negative_percentage = (total_negative / total_terms) * 100
              
              return positive_percentage, negative_percentage
              
          def count_items_with_aspect(data, aspect_name):
              """
              Count the number of items containing a specific aspect
              
              Args:
              data (list): The list of tagged reviews
              aspect_name (str): The name of the aspect to analyze
              
              Returns:
              int: The count of items containing the aspect
              """
              count = 0
              for item in data:
                  if item.get(aspect_name):
                      count += 1
              return count
  LambdaFunctionReviewsDetails:
    Type: AWS::Lambda::Function
    Properties:
      Handler: index.lambda_handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Runtime: python3.10
      Timeout: 60
      MemorySize: 512
      EphemeralStorage:
       Size: 512
      Code:
        ZipFile: |
          import json
          import boto3
          import logging
          from botocore.exceptions import ClientError

          # 初始化日志
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          # 创建 DynamoDB 客户端
          dynamodb = boto3.resource('dynamodb')

          def lambda_handler(event, context):
              
              # 从event中获取category_id类型, 检查合理性
              try: 
                  category_id = int(event.get('category_id'))
              except (TypeError, ValueError):
                  logger.error("Invalid or missing category_id in the request")
                  return {'statusCode': 400, 'body': json.dumps('Invalid or missing category_id')}
              
              
              try: 
                  # 连接到指定的表
                  table_name = f'tagged_reviews_{category_id}'
                  table = dynamodb.Table(table_name)
                  # 扫描表以获取所有数据
                  data = scan_table_completely(table)
              except Exception as e:
                  logger.error(f"Unexpected error: {str(e)}")
                  return {'statusCode': 500, 'body': json.dumps('An unexpected error occurred')}
              
              return {
                  'statusCode': 200,
                  'body': json.dumps(data)
              }
              
          def scan_table_completely(table):
              """
              完整扫描DynamoDB表，处理分页
              
              Args:
              table (boto3.resource('dynamodb').Table): DynamoDB表对象
              
              Returns:
              list: 表中所有项目的列表
              """
              data = []
              scan_kwargs = {}
              done = False
              start_key = None
              while not done:
                  if start_key:
                      scan_kwargs['ExclusiveStartKey'] = start_key
                  response = table.scan(**scan_kwargs)
                  data.extend(response.get('Items', []))
                  start_key = response.get('LastEvaluatedKey', None)
                  done = start_key is None
              return data

              


  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: "Allow"
            Principal:
              Service: "lambda.amazonaws.com"
            Action: "sts:AssumeRole"
      ManagedPolicyArns:
        - "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
        - "arn:aws:iam::aws:policy/AmazonDynamoDBFullAccess"
        - "arn:aws:iam::aws:policy/AmazonBedrockFullAccess"
  
  ApiGatewayRestApi:
    Type: AWS::ApiGateway::RestApi
    Properties:
      Name: vocworkshop
      Description: REST APIs For VOC workshop
      FailOnWarnings: true
      EndpointConfiguration:
        Types:
          - REGIONAL

  ApiGatewayResourceDataPreview:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ParentId: !GetAtt ApiGatewayRestApi.RootResourceId
      PathPart: "preview_data"
  ApiGatewayResourceGenerateTags:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ParentId: !GetAtt ApiGatewayRestApi.RootResourceId
      PathPart: "generate_tags"
  ApiGatewayResourceReviewAnalysis:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ParentId: !GetAtt ApiGatewayRestApi.RootResourceId
      PathPart: "review_analysis"
  ApiGatewayResourceAnalysisMetrics:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ParentId: !GetAtt ApiGatewayRestApi.RootResourceId
      PathPart: "analysis_metrics"
  ApiGatewayResourceReviewsDetails:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ParentId: !GetAtt ApiGatewayRestApi.RootResourceId
      PathPart: "analysis_details"

  ApiGatewayMethodDataPreview:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ResourceId: !Ref ApiGatewayResourceDataPreview
      HttpMethod: POST
      AuthorizationType: NONE
      Integration:
        IntegrationHttpMethod: POST
        Type: AWS
        Uri: !Sub arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${LambdaFunctionDataPreview.Arn}/invocations
        IntegrationResponses:
          - StatusCode: 200
            ResponseTemplates:
              application/json: ''
      MethodResponses:
        - StatusCode: 200
          ResponseModels:
            application/json: 'Empty'
  ApiGatewayMethodGenerateTags:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ResourceId: !Ref ApiGatewayResourceGenerateTags
      HttpMethod: POST
      AuthorizationType: NONE
      Integration:
        IntegrationHttpMethod: POST
        Type: AWS
        Uri: !Sub arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${LambdaFunctionGenerateTags.Arn}/invocations
        TimeoutInMillis: 29000 
        IntegrationResponses:
          - StatusCode: 200
            ResponseTemplates:
              application/json: ''
      MethodResponses:
        - StatusCode: 200
          ResponseModels:
            application/json: 'Empty'
  ApiGatewayMethodReviewAnalysis:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ResourceId: !Ref ApiGatewayResourceReviewAnalysis
      HttpMethod: POST
      AuthorizationType: NONE
      Integration:
        IntegrationHttpMethod: POST
        Type: AWS
        Uri: !Sub arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${LambdaFunctionReviewAnalysis.Arn}/invocations
        TimeoutInMillis: 29000 
        IntegrationResponses:
          - StatusCode: 200
            ResponseTemplates:
              application/json: ''
      MethodResponses:
        - StatusCode: 200
          ResponseModels:
            application/json: 'Empty'
 
  ApiGatewayMethodAnalysisMetrics:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ResourceId: !Ref ApiGatewayResourceAnalysisMetrics
      HttpMethod: POST
      AuthorizationType: NONE
      Integration:
        IntegrationHttpMethod: POST
        Type: AWS
        Uri: !Sub arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${LambdaFunctionAnalysisMetrics.Arn}/invocations
        TimeoutInMillis: 29000 
        IntegrationResponses:
          - StatusCode: 200
            ResponseTemplates:
              application/json: ''
      MethodResponses:
        - StatusCode: 200
          ResponseModels:
            application/json: 'Empty'
  
  ApiGatewayMethodReviewsDetails:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ResourceId: !Ref ApiGatewayResourceReviewsDetails
      HttpMethod: POST
      AuthorizationType: NONE
      Integration:
        IntegrationHttpMethod: POST
        Type: AWS
        Uri: !Sub arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${LambdaFunctionReviewsDetails.Arn}/invocations
        TimeoutInMillis: 29000 
        IntegrationResponses:
          - StatusCode: 200
            ResponseTemplates:
              application/json: ''
      MethodResponses:
        - StatusCode: 200
          ResponseModels:
            application/json: 'Empty'

  # Add OPTIONS method for CORS
  ApiGatewayMethodDataPreviewOptions:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ResourceId: !Ref ApiGatewayResourceDataPreview
      HttpMethod: OPTIONS
      AuthorizationType: NONE
      Integration:
        IntegrationResponses:
          - StatusCode: '200'
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
              method.response.header.Access-Control-Allow-Methods: "'POST,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
        PassthroughBehavior: WHEN_NO_MATCH
        RequestTemplates:
          application/json: '{"statusCode": 200}'
        Type: MOCK
      MethodResponses:
        - StatusCode: '200'
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Origin: true
  ApiGatewayMethodGenerateTagsOptions:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ResourceId: !Ref ApiGatewayResourceGenerateTags
      HttpMethod: OPTIONS
      AuthorizationType: NONE
      Integration:
        IntegrationResponses:
          - StatusCode: '200'
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
              method.response.header.Access-Control-Allow-Methods: "'POST,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
        PassthroughBehavior: WHEN_NO_MATCH
        RequestTemplates:
          application/json: '{"statusCode": 200}'
        Type: MOCK
      MethodResponses:
        - StatusCode: '200'
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Origin: true
  ApiGatewayMethodReviewAnalysisOptions:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ResourceId: !Ref ApiGatewayResourceReviewAnalysis
      HttpMethod: OPTIONS
      AuthorizationType: NONE
      Integration:
        IntegrationResponses:
          - StatusCode: '200'
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
              method.response.header.Access-Control-Allow-Methods: "'POST,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
        PassthroughBehavior: WHEN_NO_MATCH
        RequestTemplates:
          application/json: '{"statusCode": 200}'
        Type: MOCK
      MethodResponses:
        - StatusCode: '200'
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Origin: true

  ApiGatewayMethodAnalysisMetricsOptions:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ResourceId: !Ref ApiGatewayResourceAnalysisMetrics
      HttpMethod: OPTIONS
      AuthorizationType: NONE
      Integration:
        IntegrationResponses:
          - StatusCode: '200'
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
              method.response.header.Access-Control-Allow-Methods: "'POST,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
        PassthroughBehavior: WHEN_NO_MATCH
        RequestTemplates:
          application/json: '{"statusCode": 200}'
        Type: MOCK
      MethodResponses:
        - StatusCode: '200'
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Origin: true

  ApiGatewayMethodReviewsDetailsOptions:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ResourceId: !Ref ApiGatewayResourceReviewsDetails
      HttpMethod: OPTIONS
      AuthorizationType: NONE
      Integration:
        IntegrationResponses:
          - StatusCode: '200'
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
              method.response.header.Access-Control-Allow-Methods: "'POST,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
        PassthroughBehavior: WHEN_NO_MATCH
        RequestTemplates:
          application/json: '{"statusCode": 200}'
        Type: MOCK
      MethodResponses:
        - StatusCode: '200'
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Origin: true
  DataPreviewLambdaInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref LambdaFunctionDataPreview
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ApiGatewayRestApi}/*/POST/preview_data
  GenerateTagsLambdaInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref LambdaFunctionGenerateTags
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ApiGatewayRestApi}/*/POST/generate_tags
  ReviewAnalysisLambdaInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref LambdaFunctionReviewAnalysis
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ApiGatewayRestApi}/*/POST/review_analysis
  AnalysisMetricsLambdaInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref LambdaFunctionAnalysisMetrics
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ApiGatewayRestApi}/*/POST/analysis_metrics
  ReviewsDetailsLambdaInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref LambdaFunctionReviewsDetails
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ApiGatewayRestApi}/*/POST/analysis_details
  ApiGatewayDeployment:
    Type: AWS::ApiGateway::Deployment
    DependsOn: 
      - ApiGatewayMethodDataPreview
      - ApiGatewayMethodDataPreviewOptions
      - ApiGatewayMethodGenerateTags
      - ApiGatewayMethodGenerateTagsOptions
      - ApiGatewayMethodReviewAnalysis
      - ApiGatewayMethodReviewAnalysisOptions
      - ApiGatewayMethodAnalysisMetrics
      - ApiGatewayMethodAnalysisMetricsOptions
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      StageName: prod


  





Outputs:
  BucketName:
    Description: 'Name of the created S3 bucket'
    Value: !Ref S3Bucket
  TagsDynamoDBTable:
    Description: 'VOC tags management table in DynamoDB'
    Value: !Ref DynamoDBTable
  ApiGatewayRestApiURL:
    Description: 'URL of API Gateway Rest API'
    Value: !Sub "https://${AWS::Region}.console.aws.amazon.com/apigateway/home?region=${AWS::Region}#/apis/${ApiGatewayRestApi}/resources"
  DataPreviewAPIURL:
    Description: URL of DataPreview API Gateway endpoint
    Value: !Sub "https://${ApiGatewayRestApi}.execute-api.${AWS::Region}.amazonaws.com/prod/preview_data"
  GenerateTagsAPIURL:
    Description: URL of DataPreview API Gateway endpoint
    Value: !Sub "https://${ApiGatewayRestApi}.execute-api.${AWS::Region}.amazonaws.com/prod/generate_tags"
  ReviewAnalysisAPIURL:
    Description: URL of DataPreview API Gateway endpoint
    Value: !Sub "https://${ApiGatewayRestApi}.execute-api.${AWS::Region}.amazonaws.com/prod/review_analysis"
  AnalysisMetricsAPIURL:
    Description: URL of DataPreview API Gateway endpoint
    Value: !Sub "https://${ApiGatewayRestApi}.execute-api.${AWS::Region}.amazonaws.com/prod/analysis_metrics"
  ReviewsDetailsAPIURL:
    Description: URL of DataPreview API Gateway endpoint
    Value: !Sub "https://${ApiGatewayRestApi}.execute-api.${AWS::Region}.amazonaws.com/prod/analysis_details"